const express = require("express");
const bodyParser = require("body-parser");
const mysql = require("mysql2");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const admin = require("firebase-admin");
const cors = require("cors");
const axios = require("axios");
const fs = require("fs");
const crypto = require("crypto");
const nodemailer = require("nodemailer");
const multer = require("multer");
require("dotenv").config();
const path = require("path");
const JWT_SECRET = process.env.JWT_SECRET;
const app = express();
const { PythonShell } = require('python-shell');

// Middleware
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors()); // Enable CORS
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));


// Create Connection Pool
const pool = mysql.createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    port: process.env.DB_PORT,
    waitForConnections: true,
    connectionLimit: 20,
    queueLimit: 0,
    connectTimeout: 60000,
  });



  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö JWT token
const verifyToken = (req, res, next) => {
  const token = req.headers['authorization'];

  if (!token) {
    return res.status(403).json({ message: "Token is required" });
  }

  // ‡∏ï‡∏±‡∏î‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "Bearer" ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å token
  const bearerToken = token.split(' ')[1];

  jwt.verify(bearerToken, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({ message: "Invalid token" });
    }
    req.userId = decoded.id; // ‡πÄ‡∏Å‡πá‡∏ö userId ‡∏à‡∏≤‡∏Å token ‡πÉ‡∏ô request object
    next(); // ‡∏™‡πà‡∏á‡∏ï‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö middleware ‡∏´‡∏£‡∏∑‡∏≠ route handler ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
  });
};

module.exports = verifyToken; // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏î‡πâ

// Storage configuration for profile picture upload
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, './uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  }
});
const upload = multer({ storage: storage });

  function generateOtp() {
    const otp = crypto.randomBytes(3).toString("hex"); // 3 bytes = 6 hex characters
    return parseInt(otp, 16).toString().slice(0, 6); // Convert hex to decimal and take first 6 digits
  }

  function sendOtpEmail(email, otp, callback) {
    const transporter = nodemailer.createTransport({
      service: "Gmail",
      auth: {
        user: process.env.email,
        pass: process.env.emailpassword,
      },
    });
    
  
    const mailOptions = {
      from: process.env.email,
      to: email,
      subject: "Your OTP Code",
      html: `
        <div style="font-family: Arial, sans-serif; color: #333;">
          <h2 style="color: #007bff;">Your OTP Code</h2>
          <p>Hello,</p>
          <p>We received a request to verify your email address. Please use the OTP code below to complete the process:</p>
          <div style="padding: 10px; border: 2px solid #007bff; display: inline-block; font-size: 24px; color: #007bff; font-weight: bold;">
            ${otp}
          </div>
          <p>This code will expire in 10 minutes.</p>
          <p>If you didnt request this, please ignore this email.</p>
          <p style="margin-top: 20px;">Thanks, <br> The Team</p>
          <hr>
          <p style="font-size: 12px; color: #999;">This is an automated email, please do not reply.</p>
        </div>
      `,
    };
  
    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.error("Error sending OTP email:", error); // Log the error for debugging purposes
        return callback({
          error: "Failed to send OTP email. Please try again later.",
        });
      }
      callback(null, info); // Proceed if the email was successfully sent
    });
  }

// User-Register-Email
app.post("/api/register/email", async (req, res) => {
  try {
      const { email, role = "user" } = req.body; // ‡∏ñ‡πâ‡∏≤ Role ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤ ‡πÉ‡∏´‡πâ Default ‡πÄ‡∏õ‡πá‡∏ô "user"

      if (!email) {
          return res.status(400).json({ error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•" });
      }

      pool.query("SELECT * FROM User WHERE Email = ?", [email], (err, results) => {
          if (err) {
              console.error("Database error during email check:", err);
              return res.status(500).json({ error: "Database error during email check" });
          }

          if (results.length > 0) {
              const user = results[0];

              // ‡∏ñ‡πâ‡∏≤ Email ‡∏ô‡∏µ‡πâ‡πÄ‡∏Ñ‡∏¢‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô Active
              if (user.Status === "active" && user.Password) {
                  return res.status(400).json({ error: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß" });
              }

              // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Ñ‡∏¢‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡πá‡∏ô deactivated ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
              if (user.Status === "deactivated") {
                  pool.query("UPDATE User SET Status = 'active' WHERE Email = ?", [email]);
                  return res.status(200).json({ message: "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á" });
              }
          }

          // **‡∏™‡∏£‡πâ‡∏≤‡∏á OTP ‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤ Expiry**
          const otp = generateOtp();
          const expiresAt = new Date(Date.now() + 3 * 60 * 1000); // OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 3 ‡∏ô‡∏≤‡∏ó‡∏µ
          const createdAt = new Date(Date.now());

          // **‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• User ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ**
          pool.query(
              `INSERT INTO User (Email, Username, Password, Role, Status) 
              VALUES (?, '', '', ?, 'pending') 
              ON DUPLICATE KEY UPDATE Status = 'pending', Role = ?`, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Role
              [email, role, role], // ‚úÖ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ Role
              (err) => {
                  if (err) {
                      console.error("Database error during User insertion or update:", err);
                      return res.status(500).json({ error: "Database error during User insertion or update" });
                  }

                  // **‡∏î‡∏∂‡∏á UserID ‡∏à‡∏≤‡∏Å Email**
                  pool.query(
                      "SELECT UserID FROM User WHERE Email = ?",
                      [email],
                      (err, results) => {
                          if (err) {
                              console.error("Error fetching UserID:", err);
                              return res.status(500).json({ error: "Database error fetching UserID" });
                          }

                          if (results.length === 0) {
                              return res.status(404).json({ error: "User not found" });
                          }

                          const userId = results[0].UserID;

                          // **‡πÅ‡∏ó‡∏£‡∏Å OTP ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ UserID ‡πÅ‡∏ó‡∏ô Email**
                          pool.query(
                              `INSERT INTO OTP (OTP_Code, Created_At, Expires_At, UserID) 
                              VALUES (?, ?, ?, ?) 
                              ON DUPLICATE KEY UPDATE OTP_Code = ?, Created_At = ?, Expires_At = ?`,
                              [otp, createdAt, expiresAt, userId, otp, createdAt, expiresAt],
                              (err) => {
                                  if (err) {
                                      console.error("Error during OTP insertion:", err);
                                      return res.status(500).json({ error: "Database error during OTP insertion" });
                                  }

                                  console.log("OTP inserted successfully");
                                  sendOtpEmail(email, otp, (error) => {
                                      if (error) return res.status(500).json({ error: "Error sending OTP email" });
                                      res.status(200).json({ message: "OTP ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì" });
                                  });
                              }
                          );
                      }
                  );
              }
          );
      });
  } catch (error) {
      console.error("Internal server error:", error);
      res.status(500).json({ error: "Internal server error" });
  }
});



//Verify-OTP
app.post("/api/register/verify-otp", async (req, res) => {
  try {
    const { email, otp } = req.body;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Email ‡∏Å‡∏±‡∏ö OTP ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏°‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!email || !otp) {
      return res.status(400).json({ error: "Email ‡∏´‡∏£‡∏∑‡∏≠ OTP ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
    }

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ UserID ‡∏à‡∏≤‡∏Å Email
    pool.query("SELECT UserID FROM User WHERE Email = ?", [email], (err, userResults) => {
      if (err) return res.status(500).json({ error: "Database error" });

      if (userResults.length === 0) {
        return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö Email ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });
      }

      const userId = userResults[0].UserID;

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ OTP ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ UserID ‡πÅ‡∏•‡∏∞ OTP
      pool.query("SELECT * FROM OTP WHERE UserID = ? AND OTP_Code = ?", [userId, otp], (err, otpResults) => {
        if (err) return res.status(500).json({ error: "Database error" });

        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö OTP ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        if (otpResults.length === 0) {
          return res.status(400).json({ error: "OTP ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
        }

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ OTP ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
        const { Expires_At } = otpResults[0];
        if (new Date() > new Date(Expires_At)) {
          return res.status(400).json({ error: "OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" });
        }

        // ‡∏ñ‡πâ‡∏≤ OTP ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
        res.status(200).json({ message: "OTP ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ" });
      });
    });
  } catch (error) {
    res.status(500).json({ error: "Internal server error" });
  }
});

// User-Set-Password (‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÉ‡∏´‡∏°‡πà)
app.post("/api/register/set-password", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: "Email ‡πÅ‡∏•‡∏∞ Password ‡∏ï‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
    }

    const hash = await bcrypt.hash(password, 10);

    // ‡∏î‡∏∂‡∏á UserID ‡∏Å‡πà‡∏≠‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô
    pool.query("SELECT UserID FROM User WHERE Email = ?", [email], (err, results) => {
      if (err) {
        console.error("Error fetching UserID:", err);
        return res.status(500).json({ error: "Database error fetching UserID" });
      }

      if (results.length === 0) {
        return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Email ‡∏ô‡∏µ‡πâ" });
      }

      const userId = results[0].UserID;

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á User ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô 'active'
      pool.query(
        "UPDATE User SET Password = ?, Status = 'pending' WHERE UserID = ?",
        [hash, userId],
        (err, results) => {
          if (err) {
            console.error("Database error during User update:", err);
            return res.status(500).json({ error: "Database error during User update" });
          }

          if (results.affectedRows === 0) {
            return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ" });
          }

          // ‡∏•‡∏ö OTP ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö UserID
          pool.query("DELETE FROM OTP WHERE UserID = ?", [userId], (err) => {
            if (err) {
              console.error("Error during OTP deletion:", err);
              return res.status(500).json({ error: "Error during OTP deletion" });
            }

            // **‡∏™‡∏£‡πâ‡∏≤‡∏á Token ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö**
            const token = jwt.sign({ id: userId }, JWT_SECRET, { expiresIn: "7d" });

            res.status(200).json({
              message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå",
              token: token
            });
          });
        }
      );
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


//Resend-OTP
app.post("/api/resend-otp/register", async (req, res) => {
  try {
    const { email } = req.body; // ‡πÉ‡∏ä‡πâ Email ‡πÅ‡∏ó‡∏ô UserID

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Email ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏°‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!email) return res.status(400).json({ error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•" });

    const newOtp = generateOtp();
    const newExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 10 ‡∏ô‡∏≤‡∏ó‡∏µ

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ Email ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á User ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á UserID
    pool.query("SELECT UserID FROM User WHERE Email = ?", [email], (err, userResults) => {
      if (err) return res.status(500).json({ error: "Database error during user lookup" });
      if (userResults.length === 0) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Email ‡∏ô‡∏µ‡πâ" });

      const userId = userResults[0].UserID; // ‡∏î‡∏∂‡∏á UserID ‡∏ó‡∏µ‡πà‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ OTP ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÅ‡∏ó‡∏£‡∏Å‡πÉ‡∏´‡∏°‡πà
      pool.query("SELECT * FROM OTP WHERE UserID = ?", [userId], (err, otpResults) => {
        if (err) return res.status(500).json({ error: "Database error during OTP check" });

        if (otpResults.length > 0) {
          // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ OTP ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
          pool.query(
            "UPDATE OTP SET OTP_Code = ?, Expires_At = ? WHERE UserID = ?",
            [newOtp, newExpiresAt, userId],
            (err) => {
              if (err) return res.status(500).json({ error: "Database error during OTP update" });

              // ‡∏™‡πà‡∏á OTP ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
              sendOtpEmail(email, newOtp, (error) => {
                if (error) return res.status(500).json({ error: "Error sending OTP email" });
                res.status(200).json({ message: "OTP ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß" });
              });
            }
          );
        } else {
          // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ OTP ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡πà‡∏≠‡∏ô ‡πÉ‡∏´‡πâ‡πÅ‡∏ó‡∏£‡∏Å‡πÉ‡∏´‡∏°‡πà
          pool.query(
            "INSERT INTO OTP (UserID, OTP_Code, Created_At, Expires_At) VALUES (?, ?, NOW(), ?)",
            [userId, newOtp, newExpiresAt],
            (err) => {
              if (err) return res.status(500).json({ error: "Database error during OTP insertion" });

              // ‡∏™‡πà‡∏á OTP ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
              sendOtpEmail(email, newOtp, (error) => {
                if (error) return res.status(500).json({ error: "Error sending OTP email" });
                res.status(200).json({ message: "OTP ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß" });
              });
            }
          );
        }
      });
    });
  } catch (error) {
    console.error("Internal error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

//Forgot-Passord
app.post("/api/forgot-password", async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Email ‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á User ‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô active
    const userCheckSql = "SELECT UserID FROM User WHERE Email = ? AND Password IS NOT NULL AND Status = 'active'";
    pool.query(userCheckSql, [email], (err, userResults) => {
      if (err) return res.status(500).json({ error: "Database error during email check", details: err });

      if (userResults.length === 0) {
        return res.status(400).json({ error: "Email not found or inactive" });
      }

      const userId = userResults[0].UserID; // ‡∏î‡∏∂‡∏á UserID ‡∏à‡∏≤‡∏Å Email

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á OTP ‡πÉ‡∏´‡∏°‡πà
      const otp = generateOtp();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 10 ‡∏ô‡∏≤‡∏ó‡∏µ

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ User ‡∏°‡∏µ OTP ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      pool.query("SELECT * FROM OTP WHERE UserID = ?", [userId], (err, otpResults) => {
        if (err) return res.status(500).json({ error: "Database error during OTP check", details: err });

        if (otpResults.length > 0) {
          // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ OTP ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
          const updateOtpSql = "UPDATE OTP SET OTP_Code = ?, Expires_At = ?, Created_At = NOW() WHERE UserID = ?";
          pool.query(updateOtpSql, [otp, expiresAt, userId], (err) => {
            if (err) return res.status(500).json({ error: "Database error during OTP update", details: err });

            sendOtpEmail(email, otp, (error) => {
              if (error) return res.status(500).json({ error: "Error sending OTP email" });
              res.status(200).json({ message: "OTP sent to email" });
            });
          });
        } else {
          // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ OTP ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ
          const saveOtpSql = "INSERT INTO OTP (UserID, OTP_Code, Expires_At, Created_At) VALUES (?, ?, ?, NOW())";
          pool.query(saveOtpSql, [userId, otp, expiresAt], (err) => {
            if (err) return res.status(500).json({ error: "Database error during OTP save", details: err });

            sendOtpEmail(email, otp, (error) => {
              if (error) return res.status(500).json({ error: "Error sending OTP email" });
              res.status(200).json({ message: "OTP sent to email" });
            });
          });
        }
      });
    });
  } catch (error) {
    console.error("Internal error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

//Verify Reset OTP
app.post("/api/verify-reset-otp", async (req, res) => {
  try {
    const { email, otp } = req.body;

    if (!email || !otp) {
      return res.status(400).json({ error: "Email ‡πÅ‡∏•‡∏∞ OTP ‡∏ï‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
    }

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ UserID ‡∏à‡∏≤‡∏Å Email ‡∏Å‡πà‡∏≠‡∏ô
    pool.query("SELECT UserID FROM User WHERE Email = ?", [email], (err, userResults) => {
      if (err) return res.status(500).json({ error: "Database error during user lookup" });
      if (userResults.length === 0) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Email ‡∏ô‡∏µ‡πâ" });

      const userId = userResults[0].UserID;

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ OTP ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á OTP ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ UserID ‡πÅ‡∏•‡∏∞ OTP ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
      pool.query(
        "SELECT OTP_Code, Expires_At FROM OTP WHERE UserID = ? AND OTP_Code = ?",
        [userId, otp],
        (err, results) => {
          if (err) return res.status(500).json({ error: "Database error during OTP verification" });

          // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö OTP ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
          if (results.length === 0) {
            return res.status(400).json({ error: "OTP ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
          }

          const { Expires_At } = results[0];
          const now = new Date();

          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          if (now > new Date(Expires_At)) {
            return res.status(400).json({ error: "OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" });
          }

          // ‡∏ñ‡πâ‡∏≤ OTP ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
          res.status(200).json({ message: "OTP ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ" });
        }
      );
    });
  } catch (error) {
    console.error("Internal error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Reset Password
app.post("/api/reset-password", async (req, res) => {
  try {
    const { email, newPassword } = req.body;

    if (!email || !newPassword) {
      return res.status(400).json({ error: "Email ‡πÅ‡∏•‡∏∞ Password ‡∏ï‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ UserID ‡∏à‡∏≤‡∏Å Email ‡∏Å‡πà‡∏≠‡∏ô
    pool.query("SELECT UserID FROM User WHERE Email = ?", [email], (err, userResults) => {
      if (err) return res.status(500).json({ error: "Database error during user lookup" });
      if (userResults.length === 0) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Email ‡∏ô‡∏µ‡πâ" });

      const userId = userResults[0].UserID;

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á User
      pool.query(
        "UPDATE User SET Password = ?, Status = 'active' WHERE Email = ?",
        [hashedPassword, email],
        (err) => {
          if (err) {
            console.error("Database error during password update:", err);
            return res.status(500).json({ error: "Database error during password update" });
          }

          // ‡∏•‡∏ö OTP ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö UserID ‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á OTP
          pool.query("DELETE FROM OTP WHERE UserID = ?", [userId], (err) => {
            if (err) {
              console.error("Error during OTP deletion:", err);
              return res.status(500).json({ error: "Error during OTP deletion" });
            }

            res.status(200).json({ message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß" });
          });
        }
      );
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Resend OTP for Reset Password
app.post("/api/resend-otp/reset-password", async (req, res) => {
  try {
    const { email } = req.body; 

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Email ‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á User
    const userCheckSql = "SELECT UserID FROM User WHERE Email = ?";
    pool.query(userCheckSql, [email], (err, userResults) => {
      if (err) return res.status(500).json({ error: "Database error during user lookup" });
      if (userResults.length === 0) return res.status(404).json({ error: "User not found" });

      const userId = userResults[0].UserID; // ‡∏î‡∏∂‡∏á UserID ‡∏à‡∏≤‡∏Å Email

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á OTP ‡πÉ‡∏´‡∏°‡πà
      const otp = generateOtp();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // OTP ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 10 ‡∏ô‡∏≤‡∏ó‡∏µ

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ User ‡∏°‡∏µ OTP ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      pool.query("SELECT * FROM OTP WHERE UserID = ?", [userId], (err, otpResults) => {
        if (err) return res.status(500).json({ error: "Database error during OTP lookup" });

        if (otpResults.length > 0) {
          // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ OTP ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
          const updateOtpSql = "UPDATE OTP SET OTP_Code = ?, Expires_At = ? WHERE UserID = ?";
          pool.query(updateOtpSql, [otp, expiresAt, userId], (err) => {
            if (err) return res.status(500).json({ error: "Database error during OTP update" });

            sendOtpEmail(email, otp, (error) => {
              if (error) return res.status(500).json({ error: "Error sending OTP email" });
              res.status(200).json({ message: "New OTP sent to email" });
            });
          });
        } else {
          // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ OTP ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ
          const insertOtpSql = "INSERT INTO OTP (UserID, OTP_Code, Created_At, Expires_At) VALUES (?, ?, NOW(), ?)";
          pool.query(insertOtpSql, [userId, otp, expiresAt], (err) => {
            if (err) return res.status(500).json({ error: "Database error during OTP insert" });

            sendOtpEmail(email, otp, (error) => {
              if (error) return res.status(500).json({ error: "Error sending OTP email" });
              res.status(200).json({ message: "New OTP sent to email" });
            });
          });
        }
      });
    });
  } catch (error) {
    console.error("Internal error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Login
app.post("/api/login", async (req, res) => {
  try {
    const { email, password, googleId } = req.body;

    // ‡∏£‡∏±‡∏ö IP Address ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    const ipAddress = req.headers["x-forwarded-for"] || req.connection.remoteAddress;

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    pool.query("SELECT * FROM User WHERE Email = ?", [email], (err, results) => {
      if (err) return res.status(500).json({ error: "Database error" });

      if (results.length === 0) {
        return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ô‡∏µ‡πâ" });
      }

      const user = results[0];

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÄ‡∏õ‡πá‡∏ô Active ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      if (user.Status !== "active") {
        return res.status(403).json({ message: "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ñ‡∏π‡∏Å‡∏£‡∏∞‡∏á‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô" });
      }

      if (googleId) {
        // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å GoogleID
        pool.query("SELECT * FROM User WHERE GoogleID = ?", [googleId], (err, results) => {
          if (err) {
            return res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });
          }
      
          if (results.length > 0) {
            // ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏¢‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏î‡πâ‡∏ß‡∏¢ Google ‡πÅ‡∏•‡πâ‡∏ß
            const user = results[0];
      
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° Role
            const token = jwt.sign({ id: user.UserID, role: user.Role }, JWT_SECRET);
      
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            pool.query("UPDATE User SET LastLogin = NOW(), LastLoginIP = ? WHERE UserID = ?", [ipAddress, user.UserID]);

            console.log(`User logged in: ${user.Email}, Role: ${user.Role}`);
      
            return res.status(200).json({
              message: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Google ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
              token,
              user: {
                id: user.UserID,
                email: user.Email,
                username: user.Username,
                role: user.Role, // ‚úÖ ‡∏™‡πà‡∏á Role ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢
              },
            });
          } else {
            // ‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å ‚Üí ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÉ‡∏´‡∏°‡πà
            pool.query(
              "INSERT INTO User (GoogleID, Email, Username, Role, LastLogin, LastLoginIP) VALUES (?, ?, ?, 'user', NOW(), ?)",
              [googleId, email, "", ipAddress],
              (err, result) => {
                if (err) {
                  return res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ç‡∏ä‡∏µ" });
                }
      
                const newUserId = result.insertId;
                const token = jwt.sign({ id: newUserId, role: "user" }, JWT_SECRET);

                console.log(`New user registered: ${email}, Role: user`);
      
                return res.status(201).json({
                  message: "‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Google ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
                  token,
                  user: {
                    id: newUserId,
                    email: email,
                    username: "",
                    role: "user", // ‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Role ‡πÄ‡∏õ‡πá‡∏ô "user" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Google Register
                  },
                });
              }
            );
          }
        });
      }
      

      // üìå ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏î‡πâ‡∏ß‡∏¢ Email + Password
      if (!password) {
        return res.status(400).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô" });
      }

      // ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏î‡πâ‡∏ß‡∏¢ Google ‡πÉ‡∏´‡πâ‡πÅ‡∏à‡πâ‡∏á‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Google Login
      if (user.GoogleID !== null) {
        return res.status(400).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Google" });
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
      if (user.FailedAttempts >= 5 && user.LastFailedAttempt) {
        const now = Date.now();
        const timeSinceLastAttempt = now - new Date(user.LastFailedAttempt).getTime();
        if (timeSinceLastAttempt < 300000) { // 5 ‡∏ô‡∏≤‡∏ó‡∏µ
          return res.status(429).json({ message: "‡∏Ñ‡∏∏‡∏ì‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÉ‡∏ô 5 ‡∏ô‡∏≤‡∏ó‡∏µ" });
        }
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô (bcrypt)
      bcrypt.compare(password, user.Password, (err, isMatch) => {
        if (err) return res.status(500).json({ error: "Error comparing passwords" });

        if (!isMatch) {
          // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô
          pool.query("UPDATE User SET FailedAttempts = FailedAttempts + 1, LastFailedAttempt = NOW() WHERE UserID = ?", [user.UserID]);
          return res.status(401).json({ message: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
        }

        // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        pool.query("UPDATE User SET FailedAttempts = 0, LastLogin = NOW(), LastLoginIP = ? WHERE UserID = ?", [ipAddress, user.UserID]);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° Role
        const token = jwt.sign({ id: user.UserID, role: user.Role }, JWT_SECRET, { expiresIn: "7d" });

        console.log(`User logged in: ${user.Email}, Role: ${user.Role}`);

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
        res.status(200).json({
          message: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          token,
          user: {
            id: user.UserID,
            email: user.Email,
            username: user.Username,
            role: user.Role, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Role ‡πÉ‡∏´‡πâ Response
          },
        });
      });
    });
  } catch (error) {
    console.error("Internal error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


// Set Profile ‡πÅ‡∏•‡∏∞ Login ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à
app.post("/api/set-profile", verifyToken, upload.single('picture'), (req, res) => {
  const { newUsername, birthday, gender } = req.body;
  const userId = req.userId; // ‡∏£‡∏±‡∏ö UserID ‡∏à‡∏≤‡∏Å token
  const picture = req.file ? `/uploads/${req.file.filename}` : null;

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ
  if (!newUsername || !picture || !birthday || !gender) {
    return res.status(400).json({ message: "New username, picture, birthday, and gender are required" });
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤ gender ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
  const validGenders = ["Male", "Female", "Other"];
  if (!validGenders.includes(gender)) {
    return res.status(400).json({ message: "Invalid gender. Please choose 'Male', 'Female', or 'Other'." });
  }

  // ‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å DD/MM/YYYY ‡πÄ‡∏õ‡πá‡∏ô YYYY-MM-DD
  const birthdayParts = birthday.split('/');
  const formattedBirthday = `${birthdayParts[2]}-${birthdayParts[1]}-${birthdayParts[0]}`;

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô Active
  const updateProfileQuery = `
    UPDATE User 
    SET Username = ?, ProfileImageURL = ?, Birthday = ?, Gender = ?, Status = 'active' 
    WHERE UserID = ?`;

  pool.query(updateProfileQuery, [newUsername, picture, formattedBirthday, gender, userId], (err) => {
    if (err) {
      console.error("Error updating profile: ", err);
      return res.status(500).json({ message: "Error updating profile" });
    }

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á Token
    pool.query("SELECT UserID, Email, Username, ProfileImageURL, Gender FROM User WHERE UserID = ?", [userId], (err, userResults) => {
      if (err) {
        console.error("Database error fetching user data:", err);
        return res.status(500).json({ message: "Error fetching user data" });
      }

      if (userResults.length === 0) {
        return res.status(404).json({ message: "User not found after profile update" });
      }

      const user = userResults[0];

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token
      const token = jwt.sign({ id: user.UserID }, JWT_SECRET, { expiresIn: "7d" });

      return res.status(200).json({
        message: "Profile set successfully. You are now logged in.",
        token,
        user: {
          id: user.UserID,
          email: user.Email,
          username: user.Username,
          profileImage: user.ProfileImageURL,
          gender: user.Gender
        },
      });
    });
  });
});

// Login with Google * ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ö‡∏ô Postman
app.post("/api/google-signin", async (req, res) => {
  try {
    const { googleId, email } = req.body;

    if (!googleId || !email) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    // Check if GoogleID already exists in the User table with 'active' or 'deactivated' status
    const checkGoogleIdSql = "SELECT * FROM User WHERE GoogleID = ? AND (Status = 'active' OR Status = 'deactivated')";
    pool.query(checkGoogleIdSql, [googleId], (err, googleIdResults) => {
      if (err) throw new Error("Database error during Google ID check");

      if (googleIdResults.length > 0) {
        const user = googleIdResults[0];

        // Reactivate user if status is 'deactivated'
        if (user.Status === "deactivated") {
          const reactivateSql = "UPDATE User SET Status = 'active', Email = ? WHERE GoogleID = ?";
          pool.query(reactivateSql, [email, googleId], (err) => {
            if (err) throw new Error("Database error during user reactivation");

            const token = jwt.sign({ id: user.UserID }, JWT_SECRET, { expiresIn: "7d" });
            return res.json({
              message: "User reactivated and authenticated successfully",
              token,
              user: {
                id: user.UserID,
                email: user.Email,
                username: user.Username,
                google_id: user.GoogleID,
                status: 'active',
              },
            });
          });
        } else {
          // If the user is already active, update email if necessary
          const updateSql = "UPDATE User SET Email = ? WHERE GoogleID = ?";
          pool.query(updateSql, [email, googleId], (err) => {
            if (err) throw new Error("Database error during user update");

            const token = jwt.sign({ id: user.UserID }, JWT_SECRET, { expiresIn: "7d" });
            return res.json({
              message: "User information updated successfully",
              token,
              user: {
                id: user.UserID,
                email: user.Email,
                username: user.Username,
                google_id: user.GoogleID,
                status: user.Status,
              },
            });
          });
        }
      } else {
        // Check if the email is already registered with another account
        const checkEmailSql = "SELECT * FROM User WHERE Email = ? AND Status = 'active'";
        pool.query(checkEmailSql, [email], (err, emailResults) => {
          if (err) throw new Error("Database error during email check");
          if (emailResults.length > 0) {
            return res.status(409).json({
              error: "Email already registered with another account",
            });
          }

          // If the user is not registered, create a new user with GoogleID, email, and status
          const insertSql = "INSERT INTO User (GoogleID, Email, Username, Status) VALUES (?, ?, '', 'active')";
          pool.query(insertSql, [googleId, email], (err, result) => {
            if (err) throw new Error("Database error during user insertion");

            const newUserId = result.insertId;
            const newUserSql = "SELECT * FROM User WHERE UserID = ?";
            pool.query(newUserSql, [newUserId], (err, newUserResults) => {
              if (err) throw new Error("Database error during new user fetch");

              const newUser = newUserResults[0];
              const token = jwt.sign({ id: newUser.UserID }, JWT_SECRET, { expiresIn: "7d" });

              return res.status(201).json({
                message: "User registered and authenticated successfully",
                token,
                user: {
                  id: newUser.UserID,
                  email: newUser.Email,
                  username: newUser.Username,
                  google_id: newUser.GoogleID,
                  status: newUser.Status,
                },
              });
            });
          });
        });
      }
    });
  } catch (error) {
    console.error(error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ---- Search ---- //

app.get("/api/search", (req, res) => {
  const { query } = req.query;

  if (!query) {
    return res.status(400).json({ error: "Search query is required" });
  }

  // Trim ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏•‡πá‡∏Å
  const searchValue = `%${query.trim().toLowerCase()}%`;

  // SQL query ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡∏∏‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡∏∏‡πâ‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
  const searchSql = `
    SELECT 
        s.StockSymbol, 
        s.Market, 
        s.CompanyName, 
        sd.StockDetailID,  -- ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° StockDetailID
        sd.Date, 
        sd.ClosePrice
    FROM Stock s
    LEFT JOIN StockDetail sd ON s.StockSymbol = sd.StockSymbol
    WHERE LOWER(s.StockSymbol) LIKE ? 
       OR LOWER(s.CompanyName) LIKE ?
    ORDER BY sd.Date DESC; 
  `;

  pool.query(searchSql, [searchValue, searchValue], (err, results) => {
    if (err) {
      console.error("Database error during search:", err);
      return res.status(500).json({ error: "Internal server error" });
    }

    if (results.length === 0) {
      return res.status(404).json({ message: "No results found" });
    }

    // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏î‡∏¢ StockSymbol
    const groupedResults = results.reduce((acc, stock) => {
      const existingStock = acc.find((item) => item.StockSymbol === stock.StockSymbol);

      if (existingStock) {
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ClosePrice ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏Ñ‡∏≤
        existingStock.prices.push({
          StockDetailID: stock.StockDetailID, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° StockDetailID
          date: stock.Date,
          close_price: stock.ClosePrice,
        });
      } else {
        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° StockSymbol ‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡∏∏‡πâ‡∏ô
        acc.push({
          StockSymbol: stock.StockSymbol,
          Market: stock.Market,
          CompanyName: stock.CompanyName,
          prices: stock.Date
            ? [
                {
                  StockDetailID: stock.StockDetailID, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° StockDetailID
                  date: stock.Date,
                  close_price: stock.ClosePrice,
                },
              ]
            : [], // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏´‡∏∏‡πâ‡∏ô ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô array ‡∏ß‡πà‡∏≤‡∏á
        });
      }

      return acc;
    }, []);

    res.json({ results: groupedResults });
  });
});



// ---- Profile ---- //

//‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
app.put(
  "/api/users/:userId/profile",
  verifyToken,
  upload.single("profileImage"),
  (req, res) => {
    const userId = req.params.userId;

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å request body
    let { username, gender, birthday } = req.body;
    const profileImage = req.file ? `/uploads/${req.file.filename}` : null;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏°‡∏≤‡∏Ñ‡∏£‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!username || !gender || !birthday) {
      return res
        .status(400)
        .json({ error: "Fields required: username, gender, and birthday" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    if (isNaN(Date.parse(birthday))) {
      return res.status(400).json({ error: "Invalid birthday format (YYYY-MM-DD expected)" });
    }

    // ‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô YYYY-MM-DD
    birthday = formatDateForSQL(birthday);

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏≤‡∏¢‡∏∏‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î
    const age = calculateAge(birthday);

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ Username ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏≠‡∏∑‡πà‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const checkUsernameSql = `SELECT UserID FROM User WHERE Username = ? AND UserID != ?`;

    pool.query(checkUsernameSql, [username, userId], (checkError, checkResults) => {
      if (checkError) {
        console.error("Error checking username:", checkError);
        return res.status(500).json({ error: "Database error while checking username" });
      }

      if (checkResults.length > 0) {
        return res.status(400).json({ error: "Username is already in use" });
      }

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      let updateProfileSql = `UPDATE User SET Username = ?, Gender = ?, Birthday = ?`;
      const updateData = [username, gender, birthday];

      // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô SQL
      if (profileImage) {
        updateProfileSql += `, ProfileImageURL = ?`;
        updateData.push(profileImage);
      }

      updateProfileSql += ` WHERE UserID = ?;`;
      updateData.push(userId);

      // ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      pool.query(updateProfileSql, updateData, (error, results) => {
        if (error) {
          console.error("Error updating profile:", error);
          return res.status(500).json({ error: "Database error while updating user profile" });
        }

        if (results.affectedRows === 0) {
          return res.status(404).json({ error: "User not found" });
        }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏≤‡∏¢‡∏∏‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì
        res.json({
          message: "Profile updated successfully",
          userProfile: {
            userId,
            username,
            gender,
            birthday,
            age,
            profileImage: profileImage || "No image uploaded"
          }
        });
      });
    });
  }
);

//‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
app.get("/api/users/:userId/profile", verifyToken, (req, res) => {
  const userId = req.params.userId;

  const getUserProfileSql = `
    SELECT UserID, Username, Email, Gender, Birthday, ProfileImageURL 
    FROM User WHERE UserID = ?;
  `;

  pool.query(getUserProfileSql, [userId], (error, results) => {
    if (error) {
      console.error("Error retrieving user profile:", error);
      return res.status(500).json({ error: "Database error while retrieving user profile" });
    }

    if (results.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const user = results[0];

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤ birthday ‡πÅ‡∏•‡∏∞ profileImage ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ
    const age = user.Birthday ? calculateAge(user.Birthday) : "N/A";
    const profileImage = user.ProfileImageURL ? user.ProfileImageURL : "/uploads/default.png";

    res.json({
      userId: user.UserID,
      username: user.Username,
      email: user.Email,
      gender: user.Gender,
      birthday: user.Birthday,
      age: age,
      profileImage: profileImage
    });
  });
});

// Helper function: ‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡πÄ‡∏õ‡πá‡∏ô YYYY-MM-DD
function formatDateForSQL(dateString) {
  const dateObj = new Date(dateString);
  const year = dateObj.getFullYear();
  const month = String(dateObj.getMonth() + 1).padStart(2, '0'); // Ensure 2 digits
  const day = String(dateObj.getDate()).padStart(2, '0'); // Ensure 2 digits
  return `${year}-${month}-${day}`;
}

// Helper function: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏≤‡∏¢‡∏∏‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î
function calculateAge(birthday) {
  const birthDate = new Date(birthday);
  const today = new Date();
  let age = today.getFullYear() - birthDate.getFullYear();
  const monthDiff = today.getMonth() - birthDate.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--; // ‡∏•‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏•‡∏á 1 ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡∏õ‡∏µ‡∏ô‡∏µ‡πâ
  }
  return age;
}

// ----Noti---- //

app.get("/api/news-notifications", verifyToken, (req, res) => {
  const today = new Date().toISOString().split("T")[0]; // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (YYYY-MM-DD)
  
  const fetchNewsNotificationsSql = `
    SELECT 
      n.NewsID,
      n.Title, 
      n.PublishedDate
    FROM News n
    WHERE DATE(n.PublishedDate) = ?
    ORDER BY n.PublishedDate DESC;
  `;

  pool.query(fetchNewsNotificationsSql, [today], (error, results) => {
    if (error) {
      console.error("Database error during fetching news notifications:", error);
      return res.status(500).json({ error: "Error fetching news notifications" });
    }

    res.json({ 
      message: "‡∏Ç‡πà‡∏≤‡∏ß‡∏™‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà", 
      date: today, 
      news: results.map(news => ({
        NewsID: news.NewsID, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ NewsID
        Title: news.Title,
        PublishedDate: news.PublishedDate
      }))
    });
  });
});


// ---- Favorites ---- //

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏∏‡πä‡∏Ñ‡∏°‡∏≤‡∏£‡πå‡∏Ñ
app.post("/api/favorites", verifyToken, (req, res) => {
  const { stock_symbol } = req.body; // ‡∏î‡∏∂‡∏á StockSymbol ‡∏à‡∏≤‡∏Å request body
  const user_id = req.userId; // ‡∏î‡∏∂‡∏á user_id ‡∏à‡∏≤‡∏Å Token ‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ StockSymbol ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  if (!stock_symbol) {
    return res.status(400).json({ error: "Stock symbol is required" });
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏´‡∏∏‡πâ‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
  const checkFollowSql = "SELECT * FROM FollowedStocks WHERE UserID = ? AND StockSymbol = ?";
  pool.query(checkFollowSql, [user_id, stock_symbol], (err, results) => {
    if (err) {
      console.error("Database error during checking followed stock:", err);
      return res.status(500).json({ error: "Database error during checking followed stock" });
    }

    if (results.length > 0) {
      return res.status(400).json({ error: "You are already following this stock" });
    }

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á FollowedStocks
    const followStockSql = "INSERT INTO FollowedStocks (UserID, StockSymbol, FollowDate) VALUES (?, ?, NOW())";
    pool.query(followStockSql, [user_id, stock_symbol], (err) => {
      if (err) {
        console.error("Database error during following stock:", err);
        return res.status(500).json({ error: "Error following stock" });
      }

      res.status(201).json({ message: "Stock followed successfully" });
    });
  });
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏¥‡∏Å‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏´‡∏∏‡πâ‡∏ô
app.delete("/api/favorites", verifyToken, (req, res) => {
  const { stock_symbol } = req.body; // ‡∏î‡∏∂‡∏á StockSymbol ‡∏à‡∏≤‡∏Å request body
  const user_id = req.userId; // ‡∏î‡∏∂‡∏á user_id ‡∏à‡∏≤‡∏Å Token ‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ StockSymbol ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  if (!stock_symbol) {
    return res.status(400).json({ error: "Stock symbol is required" });
  }

  // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
  const deleteFollowedStockSql = "DELETE FROM FollowedStocks WHERE UserID = ? AND StockSymbol = ?";
  pool.query(deleteFollowedStockSql, [user_id, stock_symbol], (err, results) => {
    if (err) {
      console.error("Database error during unfollowing stock:", err);
      return res.status(500).json({ error: "Error unfollowing stock" });
    }

    if (results.affectedRows === 0) {
      return res.status(404).json({ message: "Stock not found in followed list or you are not authorized to remove" });
    }

    res.json({ message: "Stock unfollowed successfully" });
  });
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏≤‡∏ü 5 ‡∏ß‡∏±‡∏ô
app.get("/api/favorites", verifyToken, (req, res) => {
  const userId = req.userId; // ‡∏î‡∏∂‡∏á userId ‡∏à‡∏≤‡∏Å Token ‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß

  // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° ‡∏û‡∏£‡πâ‡∏≠‡∏° FollowID
  const fetchFavoritesSql = `
    SELECT fs.FollowID, fs.StockSymbol
    FROM FollowedStocks fs
    WHERE fs.UserID = ?;
  `;

  pool.query(fetchFavoritesSql, [userId], (err, stockResults) => {
    if (err) {
      console.error("Database error during fetching favorites:", err);
      return res.status(500).json({ error: "Error fetching favorite stocks" });
    }

    if (stockResults.length === 0) {
      return res.status(404).json({ message: "No followed stocks found" });
    }

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î (ClosePrice) ‡πÅ‡∏•‡∏∞ Change (%) 5 ‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏∏‡πâ‡∏ô
    const stockSymbols = stockResults.map(stock => stock.StockSymbol);

    const fetchStockDetailsSql = `
      SELECT StockSymbol, ClosePrice, Changepercen AS ChangePercentage, Date
      FROM StockDetail
      WHERE StockSymbol IN (?) 
      ORDER BY Date DESC;
    `;

    pool.query(fetchStockDetailsSql, [stockSymbols], (err, priceResults) => {
      if (err) {
        console.error("Database error during fetching stock details:", err);
        return res.status(500).json({ error: "Error fetching stock details" });
      }

      // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏´‡∏∏‡πâ‡∏ô
      const stockDataMap = {};
      stockResults.forEach(stock => {
        stockDataMap[stock.StockSymbol] = {
          FollowID: stock.FollowID, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° FollowID
          StockSymbol: stock.StockSymbol,
          LastPrice: null, // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
          LastChange: null, // ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
          HistoricalPrices: [] // ‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô
        };
      });

      priceResults.forEach(price => {
        if (!stockDataMap[price.StockSymbol].LastPrice) {
          // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
          stockDataMap[price.StockSymbol].LastPrice = price.ClosePrice;
          stockDataMap[price.StockSymbol].LastChange = price.ChangePercentage;
        }

        if (stockDataMap[price.StockSymbol].HistoricalPrices.length < 5) {
          stockDataMap[price.StockSymbol].HistoricalPrices.push({
            Date: price.Date,
            ClosePrice: price.ClosePrice
          });
        }
      });

      // ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô Array ‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°
      res.json(Object.values(stockDataMap));
    });
  });
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10 ‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î ‡πÅ‡∏•‡∏∞ ID
app.get("/api/top-10-stocks", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0].LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10 ‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î ‡πÅ‡∏•‡∏∞ StockDetailID
      const query = `
        SELECT sd.StockDetailID, s.StockSymbol, sd.Changepercen AS ChangePercentage, sd.ClosePrice
        FROM StockDetail sd
        JOIN Stock s ON sd.StockSymbol = s.StockSymbol
        WHERE sd.Date = ?
        ORDER BY sd.Changepercen DESC
        LIMIT 10;
      `;

      pool.query(query, [latestDate], (err, results) => {
        if (err) {
          console.error("Database error fetching top 10 stocks:", err);
          return res.status(500).json({ error: "Database error fetching top 10 stocks" });
        }

        res.json({
          date: latestDate,
          topStocks: results.map(stock => ({
            StockDetailID: stock.StockDetailID, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° ID ‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πâ‡∏ô
            StockSymbol: stock.StockSymbol,
            ChangePercentage: stock.ChangePercentage,
            ClosePrice: stock.ClosePrice
          }))
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á 3 ‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô
app.get("/api/trending-stocks", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0].LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡πÅ‡∏£‡∏Å
      const trendingStocksQuery = `
        SELECT 
          sd.StockDetailID,
          sd.Date, 
          s.StockSymbol, 
          sd.Changepercen AS ChangePercentage, 
          sd.ClosePrice,
          sd.PredictionClose,
          s.Market
        FROM StockDetail sd
        JOIN Stock s ON sd.StockSymbol = s.StockSymbol
        WHERE sd.Date = ?
        ORDER BY s.Market DESC, sd.Changepercen DESC
        LIMIT 3;
      `;

      pool.query(trendingStocksQuery, [latestDate], (err, trendingStocks) => {
        if (err) {
          console.error("Database error fetching trending stocks:", err);
          return res.status(500).json({ error: "Database error fetching trending stocks" });
        }

        const stockSymbols = trendingStocks.map(stock => stock.StockSymbol);

        if (stockSymbols.length === 0) {
          return res.status(404).json({ error: "No trending stocks found" });
        }

        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô (‡∏ô‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
        const historyQuery = `
          SELECT 
            StockSymbol, 
            Date, 
            ClosePrice
          FROM StockDetail
          WHERE StockSymbol IN (?) 
          ORDER BY Date DESC
          LIMIT ?;
        `;

        pool.query(historyQuery, [stockSymbols, stockSymbols.length * 5], (err, historyData) => {
          if (err) {
            console.error("Database error fetching historical data:", err);
            return res.status(500).json({ error: "Database error fetching historical data" });
          }

          // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏° StockSymbol
          const historyMap = {};
          historyData.forEach(entry => {
            if (!historyMap[entry.StockSymbol]) {
              historyMap[entry.StockSymbol] = [];
            }
            if (historyMap[entry.StockSymbol].length < 5) {
              historyMap[entry.StockSymbol].push({
                Date: entry.Date,
                ClosePrice: entry.ClosePrice
              });
            }
          });

          // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á JSON ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
          const response = {
            date: latestDate,
            trendingStocks: trendingStocks.map(stock => {
              const priceChangePercentage = stock.PredictionClose
                ? ((stock.PredictionClose - stock.ClosePrice) / stock.ClosePrice) * 100
                : null;

              let stockType = stock.Market === "America" ? "US Stock" : "TH Stock";

              return {
                StockDetailID: stock.StockDetailID, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° ID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á
                Date: stock.Date,
                StockSymbol: stock.StockSymbol,
                ChangePercentage: stock.ChangePercentage,
                ClosePrice: stock.ClosePrice,
                PredictionClose: stock.PredictionClose,
                PricePredictionChange: priceChangePercentage ? priceChangePercentage.toFixed(2) + "%" : "N/A",
                Type: stockType,
                HistoricalPrices: historyMap[stock.StockSymbol] || []
              };
            })
          };

          res.json(response);
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


// ---- News ---- //

app.get("/api/latest-news", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    const latestDateQuery = "SELECT MAX(PublishedDate) AS LatestDate FROM News";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0].LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No news data available" });
      }

      // ‡∏î‡∏∂‡∏á‡∏Ç‡πà‡∏≤‡∏ß‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á News (‡πÄ‡∏û‡∏¥‡πà‡∏° NewsID)
      const newsQuery = `
        SELECT NewsID, Title, Sentiment, PublishedDate 
        FROM News 
        WHERE PublishedDate = ?
        ORDER BY PublishedDate DESC
        LIMIT 10;
      `;

      pool.query(newsQuery, [latestDate], (err, results) => {
        if (err) {
          console.error("Database error fetching latest news:", err);
          return res.status(500).json({ error: "Database error fetching latest news" });
        }

        res.json({
          date: latestDate,
          news: results.map(news => ({
            NewsID: news.NewsID,  // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° NewsID
            Title: news.Title,
            Sentiment: news.Sentiment,
            PublishedDate: news.PublishedDate
          }))
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

//Detail News
app.get("/api/news-detail", async (req, res) => {
  try {
    const { id } = req.query; // ‡πÉ‡∏ä‡πâ NewsID ‡πÅ‡∏ó‡∏ô Title
    if (!id) {
      return res.status(400).json({ error: "News ID is required" });
    }

    // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡πà‡∏≤‡∏ß‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ NewsID
    const newsDetailQuery = `
      SELECT NewsID, Title, Sentiment, Source, PublishedDate, ConfidenceScore, Content, URL
      FROM News
      WHERE NewsID = ?
      LIMIT 1;
    `;

    pool.query(newsDetailQuery, [id], (err, results) => {
      if (err) {
        console.error("Database error fetching news detail:", err);
        return res.status(500).json({ error: "Database error fetching news detail" });
      }

      if (results.length === 0) {
        return res.status(404).json({ error: "News not found" });
      }

      const news = results[0];

      // ‡πÅ‡∏õ‡∏•‡∏á ConfidenceScore ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå
      const confidencePercentage = `${(news.ConfidenceScore * 100).toFixed(0)}%`;

      res.json({
        NewsID: news.NewsID,
        Title: news.Title,
        Sentiment: news.Sentiment,
        Source: news.Source,
        PublishedDate: news.PublishedDate,
        ConfidenceScore: confidencePercentage, // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå
        Content: news.Content,
        URL: news.URL
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏¥‡∏ô USD ‚Üí THB ‡∏à‡∏≤‡∏Å API ‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å
async function getExchangeRate() {
  try {
    const response = await fetch("https://api.exchangerate-api.com/v4/latest/USD");
    const data = await response.json();
    return data.rates.THB || 1; // ‡∏ñ‡πâ‡∏≤‡∏Ñ‡πà‡∏≤ THB ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ 1 (‡πÑ‡∏°‡πà‡πÅ‡∏õ‡∏•‡∏á)
  } catch (error) {
    console.error("Error fetching exchange rate:", error);
    return 1; // ‡∏ñ‡πâ‡∏≤‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ 1 (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô error)
  }
}

// API ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡∏∏‡πâ‡∏ô
app.get("/api/stock-detail/:symbol", async (req, res) => {
  try {
    const { symbol } = req.params;
    const { timeframe = "5D" } = req.query; // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡πá‡∏ô 5 ‡∏ß‡∏±‡∏ô

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
    const historyLimits = { "1D": 1, "5D": 5, "30D": 30, "6M": 180 };

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ timeframe ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!historyLimits[timeframe]) {
      return res.status(400).json({ error: "Invalid timeframe. Choose from 1D, 5D, 30D, 6M." });
    }

    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, async (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0]?.LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πâ‡∏ô
      const stockQuery = `
        SELECT 
          sd.StockDetailID, 
          s.StockSymbol, 
          s.Market, 
          s.CompanyName, 
          s.Sector, 
          s.Industry, 
          s.Description, 
          sd.OpenPrice, 
          sd.ClosePrice, 
          sd.Changepercen AS ChangePercentage, 
          sd.Volume, 
          sd.PredictionClose, 
          sd.PredictionTrend  -- ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° PredictionTrend
        FROM Stock s
        LEFT JOIN StockDetail sd ON s.StockSymbol = sd.StockSymbol AND sd.Date = ?
        WHERE s.StockSymbol = ?;
      `;

      pool.query(stockQuery, [latestDate, symbol], async (err, results) => {
        if (err) {
          console.error("Database error fetching stock details:", err);
          return res.status(500).json({ error: "Database error fetching stock details" });
        }

        if (results.length === 0) {
          return res.status(404).json({ error: "Stock not found" });
        }

        const stock = results[0];

        // ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ Type ‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πâ‡∏ô‡∏à‡∏≤‡∏Å Market
        let stockType = stock.Market === "America" ? "US Stock" : "TH Stock";

        // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡πÅ‡∏•‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô USD ‚Üí THB ‡∏ñ‡πâ‡∏≤‡∏´‡∏∏‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡∏•‡∏≤‡∏î‡∏≠‡πÄ‡∏°‡∏£‡∏¥‡∏Å‡∏≤
        let exchangeRate = 1;
        if (stockType === "US Stock") {
          exchangeRate = await getExchangeRate();
        }

        // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤ ClosePrice ‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô THB ‡∏ñ‡πâ‡∏≤‡∏´‡∏∏‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á US
        const closePrice = stock.ClosePrice !== null ? parseFloat(stock.ClosePrice) : 0;
        const closePriceTHB = stockType === "US Stock" ? closePrice * exchangeRate : closePrice;

        // ‚úÖ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì % ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á Prediction Close
        let pricePredictionChange = stock.PredictionClose
          ? ((stock.PredictionClose - stock.ClosePrice) / stock.ClosePrice) * 100
          : null;

        // ‚úÖ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ Volume 30 ‡∏ß‡∏±‡∏ô
        const avgVolumeQuery = `
          SELECT AVG(Volume) AS AvgVolume30D 
          FROM StockDetail 
          WHERE StockSymbol = ? 
          ORDER BY Date DESC 
          LIMIT 30;
        `;

        pool.query(avgVolumeQuery, [symbol], (volErr, volResults) => {
          if (volErr) {
            console.error("Database error fetching average volume:", volErr);
            return res.status(500).json({ error: "Database error fetching average volume" });
          }
        
          // ‚úÖ ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ .toFixed(2) ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô null
          const avgVolume30D = volResults[0]?.AvgVolume30D ? parseFloat(volResults[0].AvgVolume30D) : 0;
          const formattedAvgVolume30D = avgVolume30D > 0 ? avgVolume30D.toFixed(2) + " Million" : "N/A";
        
          // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏° Timeframe ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
          const historyQuery = `
            SELECT StockSymbol, Date, ClosePrice
            FROM StockDetail 
            WHERE StockSymbol = ? 
            ORDER BY Date DESC 
            LIMIT ?;
          `;
        
          pool.query(historyQuery, [symbol, historyLimits[timeframe]], (histErr, historyResults) => {
            if (histErr) {
              console.error(`Database error fetching historical data:`, histErr);
              return res.status(500).json({ error: "Database error fetching historical data" });
            }
        
            // ‚úÖ ‡∏™‡πà‡∏á Response ‡∏Å‡∏•‡∏±‡∏ö
            res.json({
              StockDetailID: stock.StockDetailID,
              StockSymbol: stock.StockSymbol,
              Type: stockType,
              ClosePrice: stock.ClosePrice,
              ClosePriceTHB: closePriceTHB.toFixed(2),
              Date: latestDate,
              Change: stock.ChangePercentage,
              PredictionClose: stock.PredictionClose,
              PredictionTrend: stock.PredictionTrend, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° PredictionTrend
              PredictionCloseDate: latestDate,
              PricePredictionChange: pricePredictionChange ? pricePredictionChange.toFixed(2) + "%" : "N/A",
              SelectedTimeframe: timeframe,
              HistoricalPrices: historyResults,
              Overview: {
                Open: stock.OpenPrice,
                Close: stock.ClosePrice,
                AvgVolume30D: formattedAvgVolume30D // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
              },
              Profile: {
                Sector: stock.Sector,
                Industry: stock.Industry,
                Description: stock.Description
              }
            });
          });
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


//Recommended US Stocks
app.get("/api/recommend-us-stocks", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0]?.LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏´‡∏∏‡πâ‡∏ô **Top 5 ‡∏Ç‡∏≠‡∏á‡∏ï‡∏•‡∏≤‡∏î US**
      const recommendQuery = `
        SELECT 
          sd.StockDetailID, 
          s.StockSymbol, 
          sd.ClosePrice, 
          sd.Changepercen AS ChangePercentage
        FROM StockDetail sd
        JOIN Stock s ON sd.StockSymbol = s.StockSymbol
        WHERE sd.Date = ? AND s.Market = 'America'
        ORDER BY ABS(sd.Changepercen) DESC
        LIMIT 5;
      `;

      pool.query(recommendQuery, [latestDate], (recErr, recommendResults) => {
        if (recErr) {
          console.error("Database error fetching recommended stocks:", recErr);
          return res.status(500).json({ error: "Database error fetching recommended stocks" });
        }

        const stockSymbols = recommendResults.map(stock => stock.StockSymbol);

        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô
        const historyQuery = `
          SELECT StockSymbol, Date, ClosePrice
          FROM StockDetail
          WHERE StockSymbol IN (?) 
          ORDER BY StockSymbol, Date DESC
        `;

        pool.query(historyQuery, [stockSymbols], (histErr, historyResults) => {
          if (histErr) {
            console.error("Database error fetching historical data:", histErr);
            return res.status(500).json({ error: "Database error fetching historical data" });
          }

          // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏° StockSymbol
          const historyMap = {};
          historyResults.forEach(entry => {
            if (!historyMap[entry.StockSymbol]) {
              historyMap[entry.StockSymbol] = [];
            }
            if (historyMap[entry.StockSymbol].length < 5) {
              historyMap[entry.StockSymbol].push({
                Date: entry.Date,
                ClosePrice: entry.ClosePrice
              });
            }
          });

          // ‡∏™‡πà‡∏á Response
          res.json({
            date: latestDate,
            recommendedStocks: recommendResults.map(stock => ({
              StockDetailID: stock.StockDetailID,
              StockSymbol: stock.StockSymbol,
              ClosePrice: stock.ClosePrice,
              Change: stock.ChangePercentage,
              HistoricalPrices: historyMap[stock.StockSymbol] || []
            }))
          });
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

//Most Held US Stocks
app.get("/api/most-held-us-stocks", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0]?.LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ï‡∏•‡∏≤‡∏î US
      const mostHeldQuery = `
        SELECT 
          sd.StockDetailID,
          s.StockSymbol, 
          s.Market, 
          sd.ClosePrice, 
          sd.Changepercen AS ChangePercentage
        FROM StockDetail sd
        JOIN Stock s ON sd.StockSymbol = s.StockSymbol
        WHERE sd.Date = ? AND s.Market = 'America'
        ORDER BY s.StockSymbol ASC;
      `;

      pool.query(mostHeldQuery, [latestDate], (mostHeldErr, mostHeldResults) => {
        if (mostHeldErr) {
          console.error("Database error fetching most held stocks:", mostHeldErr);
          return res.status(500).json({ error: "Database error fetching most held stocks" });
        }

        const stockSymbols = mostHeldResults.map(stock => stock.StockSymbol);

        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô
        const historyQuery = `
          SELECT StockSymbol, Date, ClosePrice
          FROM StockDetail
          WHERE StockSymbol IN (?) 
          ORDER BY StockSymbol, Date DESC;
        `;

        pool.query(historyQuery, [stockSymbols], (histErr, historyResults) => {
          if (histErr) {
            console.error("Database error fetching historical data:", histErr);
            return res.status(500).json({ error: "Database error fetching historical data" });
          }

          // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏° StockSymbol
          const historyMap = {};
          historyResults.forEach(entry => {
            if (!historyMap[entry.StockSymbol]) {
              historyMap[entry.StockSymbol] = [];
            }
            if (historyMap[entry.StockSymbol].length < 5) {
              historyMap[entry.StockSymbol].push({
                Date: entry.Date,
                ClosePrice: entry.ClosePrice
              });
            }
          });

          // ‡∏™‡πà‡∏á Response
          res.json({
            date: latestDate,
            mostHeldStocks: mostHeldResults.map(stock => ({
              StockDetailID: stock.StockDetailID,
              StockSymbol: stock.StockSymbol,
              Type: "US Stock",
              ClosePrice: stock.ClosePrice,
              Change: stock.ChangePercentage,
              HistoricalPrices: historyMap[stock.StockSymbol] || []
            }))
          });
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

//Recommended TH Stocks
app.get("/api/recommend-th-stocks", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0]?.LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏´‡∏∏‡πâ‡∏ô **Top 5 ‡∏Ç‡∏≠‡∏á‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏ó‡∏¢**
      const recommendQuery = `
        SELECT 
          sd.StockDetailID, 
          s.StockSymbol, 
          sd.ClosePrice, 
          sd.Changepercen AS ChangePercentage
        FROM StockDetail sd
        JOIN Stock s ON sd.StockSymbol = s.StockSymbol
        WHERE sd.Date = ? AND s.Market = 'Thailand'
        ORDER BY ABS(sd.Changepercen) DESC
        LIMIT 5;
      `;

      pool.query(recommendQuery, [latestDate], (recErr, recommendResults) => {
        if (recErr) {
          console.error("Database error fetching recommended Thai stocks:", recErr);
          return res.status(500).json({ error: "Database error fetching recommended Thai stocks" });
        }

        const stockSymbols = recommendResults.map(stock => stock.StockSymbol);

        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô
        const historyQuery = `
          SELECT StockSymbol, Date, ClosePrice
          FROM StockDetail
          WHERE StockSymbol IN (?) 
          ORDER BY StockSymbol, Date DESC
        `;

        pool.query(historyQuery, [stockSymbols], (histErr, historyResults) => {
          if (histErr) {
            console.error("Database error fetching historical data:", histErr);
            return res.status(500).json({ error: "Database error fetching historical data" });
          }

          // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏° StockSymbol
          const historyMap = {};
          historyResults.forEach(entry => {
            if (!historyMap[entry.StockSymbol]) {
              historyMap[entry.StockSymbol] = [];
            }
            if (historyMap[entry.StockSymbol].length < 5) {
              historyMap[entry.StockSymbol].push({
                Date: entry.Date,
                ClosePrice: entry.ClosePrice
              });
            }
          });

          // ‡∏™‡πà‡∏á Response
          res.json({
            date: latestDate,
            recommendedStocks: recommendResults.map(stock => ({
              StockDetailID: stock.StockDetailID,
              StockSymbol: stock.StockSymbol,
              ClosePrice: stock.ClosePrice,
              Change: stock.ChangePercentage,
              HistoricalPrices: historyMap[stock.StockSymbol] || []
            }))
          });
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

//Most Held Thai Stocks
app.get("/api/most-held-th-stocks", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    const latestDateQuery = "SELECT MAX(Date) AS LatestDate FROM StockDetail";
    pool.query(latestDateQuery, (dateErr, dateResults) => {
      if (dateErr) {
        console.error("Database error fetching latest date:", dateErr);
        return res.status(500).json({ error: "Database error fetching latest date" });
      }

      const latestDate = dateResults[0]?.LatestDate;
      if (!latestDate) {
        return res.status(404).json({ error: "No stock data available" });
      }

      // ‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ï‡∏•‡∏≤‡∏î‡πÑ‡∏ó‡∏¢
      const mostHeldQuery = `
        SELECT 
          sd.StockDetailID,
          s.StockSymbol, 
          s.Market, 
          sd.ClosePrice, 
          sd.Changepercen AS ChangePercentage
        FROM StockDetail sd
        JOIN Stock s ON sd.StockSymbol = s.StockSymbol
        WHERE sd.Date = ? AND s.Market = 'Thailand'
        ORDER BY s.StockSymbol ASC;
      `;

      pool.query(mostHeldQuery, [latestDate], (mostHeldErr, mostHeldResults) => {
        if (mostHeldErr) {
          console.error("Database error fetching most held Thai stocks:", mostHeldErr);
          return res.status(500).json({ error: "Database error fetching most held Thai stocks" });
        }

        const stockSymbols = mostHeldResults.map(stock => stock.StockSymbol);

        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏±‡∏ô
        const historyQuery = `
          SELECT StockSymbol, Date, ClosePrice
          FROM StockDetail
          WHERE StockSymbol IN (?) 
          ORDER BY StockSymbol, Date DESC;
        `;

        pool.query(historyQuery, [stockSymbols], (histErr, historyResults) => {
          if (histErr) {
            console.error("Database error fetching historical data:", histErr);
            return res.status(500).json({ error: "Database error fetching historical data" });
          }

          // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏° StockSymbol
          const historyMap = {};
          historyResults.forEach(entry => {
            if (!historyMap[entry.StockSymbol]) {
              historyMap[entry.StockSymbol] = [];
            }
            if (historyMap[entry.StockSymbol].length < 5) {
              historyMap[entry.StockSymbol].push({
                Date: entry.Date,
                ClosePrice: entry.ClosePrice
              });
            }
          });

          // ‡∏™‡πà‡∏á Response
          res.json({
            date: latestDate,
            mostHeldStocks: mostHeldResults.map(stock => ({
              StockDetailID: stock.StockDetailID,
              StockSymbol: stock.StockSymbol,
              Type: "TH Stock",
              ClosePrice: stock.ClosePrice,
              Change: stock.ChangePercentage,
              HistoricalPrices: historyMap[stock.StockSymbol] || []
            }))
          });
        });
      });
    });
  } catch (error) {
    console.error("Internal server error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


//-----------------------------------------------------------------------------------------------------------------------------------------------//

// API ‡πÉ‡∏´‡πâ React ‡∏î‡∏∂‡∏á Secure Embed URL ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ
app.get("/get-embed-url", (req, res) => {
  res.json({
    embedUrl:
      "https://app.powerbi.com/view?r=eyJrIjoiOGU0ZjNhMjktYjJiZC00ODA1LWIzM2EtNzNkNDg0NzhhMzVkIiwidCI6IjU3ZDY5NWQ0LWFkODYtNDRkMy05Yzk1LTcxNzZkZWFjZjAzZCIsImMiOjEwfQ%3D%3D",
  });
});

//Admin//
app.post("/api/admin/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÅ‡∏•‡∏∞‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô" });
    }

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Admin ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Active
    const sql = "SELECT * FROM User WHERE Email = ? AND Status = 'active' AND Role = 'admin'";
    pool.query(sql, [email], (err, results) => {
      if (err) {
        console.error("Database error during admin login:", err);
        return res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö" });
      }

      if (results.length === 0) {
        return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏ñ‡∏π‡∏Å‡∏£‡∏∞‡∏á‡∏±‡∏ö" });
      }

      const user = results[0];

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô
      bcrypt.compare(password, user.Password, (err, isMatch) => {
        if (err) {
          console.error("Password comparison error:", err);
          return res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô" });
        }

        if (!isMatch) {
          return res.status(401).json({ message: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
        }

        // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token (‡πÑ‡∏°‡πà‡∏°‡∏µ LastLogin / LastLoginIP)
        const token = jwt.sign({ id: user.UserID, role: user.Role }, JWT_SECRET, { expiresIn: "7d" });

        // ‚úÖ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Response
        res.status(200).json({
          message: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          token,
          user: {
            id: user.UserID,
            email: user.Email,
            username: user.Username,
            profile_image: user.ProfileImageURL,
            role: user.Role
          },
        });
      });
    });
  } catch (error) {
    console.error("Internal error:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// üìå ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Admin ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
app.get("/api/admin/users", verifyToken, verifyAdmin, (req, res) => {
  const fetchUsersSql = "SELECT UserID, Email, Username, Role, Status FROM User";

  pool.query(fetchUsersSql, (err, results) => {
    if (err) {
      console.error("Database error during fetching users:", err);
      return res.status(500).json({ error: "Error fetching users" });
    }
    res.json(results);
  });
});

// üìå ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏≤‡∏° UserID (‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Admin ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
app.get("/api/admin/users/:id", verifyToken, verifyAdmin, (req, res) => {
  const { id } = req.params;

  const fetchUserSql = "SELECT UserID, Email, Username, Role, Status FROM User WHERE UserID = ?";
  pool.query(fetchUserSql, [id], (err, results) => {
    if (err) {
      console.error("Database error during fetching user:", err);
      return res.status(500).json({ error: "Error fetching user" });
    }

    if (results.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json(results[0]);
  });
});

// üìå ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ (‡πÄ‡∏ä‡πà‡∏ô ‡∏£‡∏∞‡∏á‡∏±‡∏ö, ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
app.put("/api/admin/users/:id/status", verifyToken, verifyAdmin, (req, res) => {
  const { id } = req.params;
  const { status } = req.body;

  if (!status) {
    return res.status(400).json({ error: "Status is required" });
  }

  const updateStatusSql = "UPDATE User SET Status = ? WHERE UserID = ?";
  pool.query(updateStatusSql, [status, id], (err, results) => {
    if (err) {
      console.error("Database error during user status update:", err);
      return res.status(500).json({ error: "Error updating user status" });
    }

    if (results.affectedRows === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json({ message: "User status updated successfully" });
  });
});

// üìå **‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ (Soft Delete) + ‡∏•‡∏ö‡πÇ‡∏û‡∏™‡∏ï‡πå + ‡∏•‡∏ö‡∏´‡∏∏‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°**
// Soft Delete User
app.delete("/api/admin/users/:id", verifyToken, (req, res) => {
  const { id } = req.params;

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô admin
  if (req.role !== "admin") {
    return res.status(403).json({ error: "Only admins are allowed to delete users." });
  }

  // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏´‡∏∏‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
  const deleteFollowedStocksSql = "DELETE FROM FollowedStocks WHERE UserID = ?";
  pool.query(deleteFollowedStocksSql, [id], (followErr, followResults) => {
    if (followErr) {
      console.error("Error deleting followed stocks:", followErr);
      return res.status(500).json({ error: "Error deleting followed stocks" });
    }

    // ‡∏•‡∏ö‡∏û‡∏≠‡∏£‡πå‡∏ï‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    const deletePortfolioSql = "DELETE FROM Portfolio WHERE UserID = ?";
    pool.query(deletePortfolioSql, [id], (portfolioErr, portfolioResults) => {
      if (portfolioErr) {
        console.error("Error deleting portfolio:", portfolioErr);
        return res.status(500).json({ error: "Error deleting portfolio" });
      }

      // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
      const deletePaperTradeSql = "DELETE FROM PaperTrade WHERE UserID = ?";
      pool.query(deletePaperTradeSql, [id], (paperTradeErr, paperTradeResults) => {
        if (paperTradeErr) {
          console.error("Error deleting paper trade:", paperTradeErr);
          return res.status(500).json({ error: "Error deleting paper trade" });
        }

        // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
        const deleteTradeHistorySql = "DELETE FROM TradeHistory WHERE UserID = ?";
        pool.query(deleteTradeHistorySql, [id], (tradeHistoryErr, tradeHistoryResults) => {
          if (tradeHistoryErr) {
            console.error("Error deleting trade history:", tradeHistoryErr);
            return res.status(500).json({ error: "Error deleting trade history" });
          }

          // ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ Soft Delete ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô 'deactivated'
          const softDeleteUserSql = "UPDATE User SET Status = 'deactivated' WHERE UserID = ?";
          pool.query(softDeleteUserSql, [id], (userErr, userResults) => {
            if (userErr) {
              console.error("Error during soft delete of user:", userErr);
              return res.status(500).json({ error: "Error during soft delete of user" });
            }

            if (userResults.affectedRows === 0) {
              return res.status(404).json({ error: "User not found" });
            }

            res.json({
              message: "User soft-deleted, their related data deleted successfully",
              deletedFollowedStocks: followResults.affectedRows,
              deletedPortfolio: portfolioResults.affectedRows,
              deletedPaperTrade: paperTradeResults.affectedRows,
              deletedTradeHistory: tradeHistoryResults.affectedRows,
            });
          });
        });
      });
    });
  });
});


























// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
  